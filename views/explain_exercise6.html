<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Change Marker</title>
        <link rel="stylesheet" href="/public/css/tutorialExam.css">
        <link rel="stylesheet" href="/public/css/contextMenu.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github.min.css">
	    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
	    <script>hljs.initHighlightingOnLoad();</script>
        <script src="//cdn.jsdelivr.net/npm/highlightjs-line-numbers.js@2.8.0/dist/highlightjs-line-numbers.min.js"></script>
        <script>hljs.initLineNumbersOnLoad();</script>
        <script src="/public/js/explain_exercise6.js"></script>
        <script  src="http://code.jquery.com/jquery-latest.min.js"></script>
    </head>
    <body onload="init();">
        <div class="container">
        <section id="section">
            <div id="left">
                <pre><code class="java" id="inner_left">package org.elasticsearch.search.fetch;

import org.apache.lucene.search.Scorer;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import static java.util.Collections.unmodifiableMap;

public class FetchPhase implements SearchPhase {

    private final FetchSubPhase[] fetchSubPhases;

    @Override
    public Map parseElements() {
        Map parseElements = new HashMap();
        for (FetchSubPhase fetchSubPhase : fetchSubPhases) {
            parseElements.putAll(fetchSubPhase.parseElements());
        }
        return unmodifiableMap(parseElements);
    }
    

    private InternalSearchHit getInternalNestedIdentity() {
        int currentParent = nestedSubDocId;
        ObjectMapper nestedParentObjectMapper;
        ObjectMapper current = nestedObjectMapper;
        String originalName = nestedObjectMapper.name();
<span class="code_delete">        private BlockServiceHandler mWorkerServiceHandler = null;</span>
        InternalSearchHit.InternalNestedIdentity nestedIdentity = null;
        do {
            Query parentFilter;
            if (nestedParentObjectMapper != null) {
                if (nestedParentObjectMapper.nested().isNested() == false) {
                    current = nestedParentObjectMapper;
                    continue;
                }
                parentFilter = nestedParentObjectMapper.nestedTypeFilter();
            } else {
                parentFilter = Queries.newNonNestedFilter();
            }

            Query childFilter = nestedObjectMapper.nestedTypeFilter();
            if (childFilter == null) {
                current = nestedParentObjectMapper;
                continue;
            }
            Scorer childScorer = childWeight.scorer(subReaderContext);
            if (childScorer == null) {
                current = nestedParentObjectMapper;
                continue;
            }
            DocIdSetIterator childIter = childScorer.iterator();

            int offset = 0;
            int nextParent = parentBits.nextSetBit(currentParent);
            currentParent = nextParent;
            current = nestedObjectMapper = nestedParentObjectMapper;
            int currentPrefix = current == null ? 0 : current.name().length() + 1;
            if (current != null) {
                originalName = current.name();
            }
        } while (current != null);
        return nestedIdentity;
    }

    private void loadStoredFields(SearchContext searchContext) {
        fieldVisitor.reset();
        try {
            readerContext.reader().document(docId, fieldVisitor);
        } catch (IOException e) {
            throw new FetchPhaseExecutionException(searchContext, e);
        }
    }
}</code></pre>
            </div>

            <div class="d1" id="hr1">
                <input type="button" class="move_inner" id="#1" value="1" onclick="move_inner()">
            </div>

            <div id="right">
                <pre><code class="java" id="inner_right">package org.elasticsearch.search.fetch;

import org.apache.lucene.search.Scorer;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import static java.util.Collections.unmodifiableMap;

public class FetchPhase implements SearchPhase {

    private final FetchSubPhase[] fetchSubPhases;

    @Override
    public Map parseElements() {
        Map parseElements = new HashMap();
        for (FetchSubPhase fetchSubPhase : fetchSubPhases) {
            parseElements.putAll(fetchSubPhase.parseElements());
        }
        return unmodifiableMap(parseElements);
    }
    

    private InternalSearchHit getInternalNestedIdentity() {
        int currentParent = nestedSubDocId;
        ObjectMapper nestedParentObjectMapper;
        ObjectMapper current = nestedObjectMapper;
        String originalName = nestedObjectMapper.name();
<span class="code_insert">        private BlockWorkerClientServiceHandler mWorkerServiceHandler = null;</span>
        InternalSearchHit.InternalNestedIdentity nestedIdentity = null;
        do {
            Query parentFilter;
            if (nestedParentObjectMapper != null) {
                if (nestedParentObjectMapper.nested().isNested() == false) {
                    current = nestedParentObjectMapper;
                    continue;
                }
                parentFilter = nestedParentObjectMapper.nestedTypeFilter();
            } else {
                parentFilter = Queries.newNonNestedFilter();
            }

            Query childFilter = nestedObjectMapper.nestedTypeFilter();
            if (childFilter == null) {
                current = nestedParentObjectMapper;
                continue;
            }
            Scorer childScorer = childWeight.scorer(subReaderContext);
            if (childScorer == null) {
                current = nestedParentObjectMapper;
                continue;
            }
            DocIdSetIterator childIter = childScorer.iterator();

            int offset = 0;
            int nextParent = parentBits.nextSetBit(currentParent);
            currentParent = nextParent;
            current = nestedObjectMapper = nestedParentObjectMapper;
            int currentPrefix = current == null ? 0 : current.name().length() + 1;
            if (current != null) {
                originalName = current.name();
            }
        } while (current != null);
        return nestedIdentity;
    }

    private void loadStoredFields(SearchContext searchContext) {
        fieldVisitor.reset();
        try {
            readerContext.reader().document(docId, fieldVisitor);
        } catch (IOException e) {
            throw new FetchPhaseExecutionException(searchContext, e);
        }
    }
}</code></pre>
            </div>
        </section>
        <div class="section_container">
            <div class="d2" id="hr2">
                Edit Script
            </div>
        </div>
        <footer id="footer">
            <table id="edit_scripts" onchange="checkExam();">
                <tr>
                    <th id="es_type">Type</th>
                    <th id="es_old">Old Code</th>
                    <th id="es_old_line">Line#</th>
                    <th id="es_new">New Code</th>
                    <th id="es_new_line">Line#</th>
                    <th id="es_opt">Option</th>
                </tr>
            </table>
        </footer>
        </div>
    </body>
</html>